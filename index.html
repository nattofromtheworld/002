<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>FBX Viewer</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { width: 100%; height: 100%; display: block; }
    </style>
</head>
<body>
    <!-- Three.jsとその関連ライブラリの読み込み -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/fflate@0.7.0/umd/index.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FBXLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script>
        // シーン、カメラ、レンダラー
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true }); // antialias: true で描画を滑らかに
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // 1. 背景を薄い青に設定
        // 0xADD8E6 は "LightBlue" のHEXカラーコードです。
        renderer.setClearColor(0xADD8E6, 1);

        // カメラの初期位置は、FBXロード後にモデルに合わせて調整するため、ここでは設定しません。
        // camera.position.set(0, 0, 5); // 以前の初期設定をコメントアウトまたは削除

        // OrbitControls
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.target.set(0, 0, 0); // 初期ターゲットは原点（モデルの中心がここに来ることを想定）
        controls.update();

        // ライト
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.1); 
        scene.add(ambientLight);
        // DirectionalLightは特定方向からの光（太陽のようなもの）。強度をさらに下げました。
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5); // 0.8 -> 0.5
        directionalLight.position.set(5, 10, 5); // 光源の位置
        directionalLight.lookAt(0, 0, 0); // 原点を見るように設定
        scene.add(directionalLight);

        // FBXローダー
        const loader = new THREE.FBXLoader();

        // アニメーションミキサーとクロック
        let mixer;
        const clock = new THREE.Clock(); // 時間の経過を計測するためのクロック

        loader.load('0012.fbx', function (object) {
            scene.add(object);

            // モデルをシーン中央に配置 (バウンディングボックスの中心を原点に移動)
            const box = new THREE.Box3().setFromObject(object);
            const center = box.getCenter(new THREE.Vector3());
            object.position.sub(center);

            // 2. モデルのサイズを指定し、カメラ位置を最適化
            // まず、モデルのスケーリング前の最大寸法を取得します。
            const initialSize = box.getSize(new THREE.Vector3());
            const maxInitialDim = Math.max(initialSize.x, initialSize.y, initialSize.z);

            // 希望するモデルの最大寸法（例：5単位）。
            // この値を調整することで、モデルの画面上での大きさを変更できます。
            const desiredModelSize = 5; 

            // スケール係数を計算し、モデルに適用
            const scaleFactor = desiredModelSize / maxInitialDim;
            object.scale.set(scaleFactor, scaleFactor, scaleFactor);

            // スケーリング後のモデルのバウンディングボックスを再計算
            const finalBox = new THREE.Box3().setFromObject(object);
            const finalSize = finalBox.getSize(new THREE.Vector3());
            const finalMaxDim = Math.max(finalSize.x, finalSize.y, finalSize.z);

            // カメラの視野角とアスペクト比を考慮して最適な距離を計算
            // モデル全体がカメラの視野に収まる最低限の距離を計算します。
            const fovRad = THREE.MathUtils.degToRad(camera.fov);
            const distance = (finalMaxDim / 2) / Math.tan(fovRad / 2);

            // 計算された距離に少し余裕を持たせて、カメラを配置
            // ここで `distance * 1.2` は、モデルが画面いっぱいに表示されるより、少し余裕を持たせるための倍率です。
            // 必要に応じて `1.0` (ぴったり) や `1.5` (もっと引く) などに調整してください。
            camera.position.set(0, 0, distance * 1.2); 
            camera.lookAt(0, 0, 0); // モデルの中心を見る
            controls.target.set(0, 0, 0); // OrbitControlsのターゲットもモデルの中心に設定
            controls.update(); // カメラ位置とターゲット変更後もcontrols.update()を忘れずに

            // 3. FBXアニメーションの再生
            if (object.animations && object.animations.length) {
                mixer = new THREE.AnimationMixer(object); // モデルに関連するミキサーを作成

                // すべてのアニメーションクリップを再生
                object.animations.forEach(clip => {
                    const action = mixer.clipAction(clip);
                    action.play(); // アニメーションを再生
                });
                console.log('FBX animations found and playing:', object.animations.length + ' clips.');
            } else {
                console.log('No animations found in this FBX file.');
            }

        }, undefined, function (error) {
            console.error('An error occurred loading the FBX file:', error);
        });

        // ウィンドウリサイズ対応
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // アニメーションループ
        function animate() {
            requestAnimationFrame(animate);

            // アニメーションミキサーの更新
            if (mixer) {
                mixer.update(clock.getDelta());
            }

            // OrbitControlsの更新
            // カメラの操作（回転、拡大縮小など）を有効にするために必要です。
            controls.update();

            renderer.render(scene, camera);
        }
        animate(); // アニメーションループを開始
    </script>
</body>
</html>
